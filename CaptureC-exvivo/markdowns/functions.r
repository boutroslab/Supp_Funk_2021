getTSS=function(gr){
  ##returns tss annotation of a gr
  gr$tss=start(gr)
  gr[strand(gr)=='-']$tss=end(gr[strand(gr)=='-'])
  return(gr)
}


getTSSgr=function(gr){
  ##returns a new gr with start/end == tss
  a=getTSS(gr)
  b=GRanges(seqnames(a),IRanges(a$tss,a$tss),strand(a))
  names(b)=names(gr)
  values(b)=values(a)
  return(b)
}



bed2gr <- function(bed){
  ##converts a bed with 3 columns to a gr
  gr=GRanges(bed[,1],IRanges(bed[,2],bed[,3]))
  if (dim(bed)[2]>3){
    names(gr)=bed[,4]
  } 
  if ('strand' %in% names(bed)){
    strand(gr)=bed$strand
  } else if ('Strand' %in% names(bed)){
    strand(gr)=bed$Strand
  }
  return(gr)
}



getInterestingParams <- function(sample, hind, baited_genes,genome=Mmusculus,genenames='genenames'){
  ##wrapping function of getting interesting_params from a ChicagoData (cd) object
  ##returns interesting_params AND also stores interesting_params in a results/interesting_params_<sample>.txt file
  ##assumes that promoter capture fragment can be found in a column called "dpn_id" in baited_genes
  ##automatically loads the genome, the cd object, determines the number of replicates and the baitIDs
  ##
  ##requires:
  ##sample: name of the cd@x object already preloaded in the list L
  ##hind: rds file with all restriction fragments generated by the enzyme used in CaptureC 
  ##baited_genes: table or rds object with baited genes
  ##genome: BSgenome object, default: Mmusculus
  ##genenames: character, name of columkn in baited_genes that contains the genenames. Default: 'genenames'
  ##
  ###example usage:
  ## library('BSgenome')
  ## library(GenomicRanges)
  ## library("BSgenome.Mmusculus.UCSC.mm10")
  ## L_interesting_params=list()
  ## for(sample in names(L)){
  ##   print(sample)
  ##   L_interesting_params=c(L_interesting_params,list(getInterestingParams(sample=sample,hind=hind,baited_genes=baited_genes)))
  ## }
  ## names(L_interesting_params)=names(L)
  ## plotInterestingParams(L_interesting_params)
  
  
  int=as.data.frame(L[[sample]])
  ids=baited_genes$dpn_id
  
  ##identify the number of replicates:
  x=names(int)[grep('N[.]',names(int))]
  if (length(x)>0){
    n=max(as.numeric(unlist(strsplit(x,'[.]'))),na.rm=TRUE)
  } else {n=0}
  
  interesting_params=lapply(ids, FUN=getParamsCd, genome=genome, int=int,hind=hind,n=n)
  interesting_params=do.call('rbind',interesting_params)
  if (class(baited_genes) != 'data.frame'){baited_genes=as.data.frame(baited_genes)}
  interesting_params$genename=baited_genes[,genenames]
  write.table(interesting_params, paste('interesting_params_',sample,'.txt',sep=''),sep='\t', eol='\n', quote=FALSE, row.names=FALSE)
  
  return(interesting_params)
}


plotInterestingParams <- function(L_interesting_params){
  ##Function to plot all potentially interesting quantifications from chicago data interesting_params
  ##L_interesting_params: List of data frames of interesting params from different samples with names(L)=names samples
  ###example usage:
  ## library('BSgenome')
  ## library(GenomicRanges)
  ## library("BSgenome.Mmusculus.UCSC.mm10")
  ## L_interesting_params=list()
  ## for(sample in names(L)){
  ##   print(sample)
  ##   L_interesting_params=c(L_interesting_params,list(getInterestingParams(sample=sample,hind=hind,baited_genes=baited_genes)))
  ## }
  ## names(L_interesting_params)=names(L)
  ## plotInterestingParams(L_interesting_params)
  
  
  for (i in 1:length(L_interesting_params)){
    
    d=L_interesting_params[[i]]
    
    w=3
    h=2
    pdf(paste('interesting_params_',names(L_interesting_params)[i],'.pdf',sep=''),onefile=TRUE, width=w*3,height=h*3)
    par(mfrow=c(h,w))
    for (j in 2:(ncol(d)-1)){
      
      if (table(factor(is.na(d[,j]),levels=c(TRUE,FALSE)))[2]!=0){
        hist(d[,j],main=names(d)[j])
        med=median(d[,j],na.rm=TRUE)
        mea=mean(d[,j],na.rm=TRUE)
        abline(v=med,col='red',lwd=2,lty=2)
        abline(v=mea,col='green',lwd=2,lty=2)
        legend('topright',lty=2,col=c('red','green'),legend=paste(c('median','mean'),c(round(med,2), round(mea,2))),bty='n',lwd=2)
      } else {
        plot(1,1,main=names(d)[j],col='white')
      }
    }
    dev.off()
    
    
  }
}






plotInteractions <- function(L, id,k,zoom, ylim=NULL,show.legend=NULL,d=NULL, name=NULL,intervals=NULL,xlim=NULL,col=NULL,colintervals=NULL,hind,troubleshooting=FALSE,lwd=2){
  ##Line plots of promoter interactions comparing up to two samples
  ##Blocks out the bait+/- 1 fragment 
  ##
  ##requires; list L with cd@x objects
  ##
  ##Arguments:
  ##L: List with cd@x objects
  ##id=baitID
  ##k=smoothing factor for the line plot
  ##zoom=+/- around the bait
  ##unt=numeric, number refers to the location of the cd@x object of sample 1 in the list L
  ##tam=numeric, number refers to the location of the cd@x object of sample 2 in the list L, only plotted if tam != unt
  ##ylim: vector, usually something about c(0,1)
  ##
  ##optional:
  ##show.legend = logical, default NULL, if TRUE legend is shows
  ##d: table of interactions in which lost, gained and stable interactions are marked, assuming that the interaction directionality is contained in a column called "clusters_refined" (up to 8 clusters are supported at the moment!)
  ##unt2: numeric, number refers to the location of the cd@x object of sample 3 in the list L
  ##tam2: numeric, number refers to the location of the cd@x object of sample 4 in the list L
  ##name: name of the promoter to plot, if not given, name=id
  ##intervals: a named GRangesList grl, up to 7 different intervals are plottable as default!
  ##xlim: example: c(1200,1300), default xlim will be determined from zoom
  ##colintervals: deafult: NULL, then 7 default colours are given, possible to give your own colours as a vector 
  
  if (!is.null(name)){
    main=paste(name,id,sep=',')
  } else {
    main=id
  }
  
  if(!is.null(d)){ 
    if('clusters_refined' %in% names(d) == FALSE){
      d$clusters_refined='interaction'
    }
    clust=unique(unlist(strsplit(d$clusters_refined,split=','))) 
  }
  
  
  if(is.null(col)){
    colors=c('blue','red','green','black','orange','lightblue','pink','purple','darkred','darkgreen')
  } else {
    colors=col
  }	
  
  if (troubleshooting){
    message(paste('getting bait...')	)
  }
  bait=getbait(id)
  if (troubleshooting){
    message(paste('bait retrieved...'))
  }
  
  if (is.null(xlim)){
    xlim=c(start(bait)-zoom,end(bait)+zoom)
  }
  
  if (troubleshooting){
    message(paste('Bait: \n',print(bait)))
  }
  
  LL=list()	##make a list with bed files for all samples
  legend=vector()
  legendcols=vector()
  all=vector()
  
  for (i in 1:length(L)){
    
    if (troubleshooting){
      message(paste('sample',i))
    }
    
    col=colors[i]
    
    samplename=names(L)[i]
    legend=c(legend,samplename)
    legendcols=c(legendcols,col)
    
    if (troubleshooting){
      message(paste('getting normbed...'))
    }
    bed=getnormbed(id,data=L[[i]],samplename = names(L)[i],L=L,same.chromosome=TRUE,bait=bait,hind=hind)
    if (troubleshooting){
      message(paste('normbed retrieved, coverage...'))
    }
    bed=bed2cov(bed,bait)
    if (troubleshooting){
      message(paste('cov retrieved, getrunmean...'))
    }
    bed=getrunmeanbed(bed,bait,xlim,k)
    if (troubleshooting){
      message(paste('runmean retrieved'))
    }
    
    LL=c(LL,list(bed))
    all=c(all,as.vector(bed$x))
    
  }
  if (troubleshooting){
    message(paste('list made'))
  }
  
  ##make plots:
  
  if(is.null(ylim)){
    ylim=max(LL[[1]]$x,na.rm=TRUE)
    
    if (length(LL)>1){
      for (j in 2:length(LL)){
        ylim=c(ylim,max(LL[[j]]$x,na.rm=TRUE))
      }
    }
    
    ylim=as.numeric(c(0,max(ylim,na.rm=TRUE)*1.2))
  }
  
  
  if (!is.null(intervals)){
    len=length(intervals)
    ylim=c(-ylim[2]/20*len,ylim[2])
  }
  
  if (troubleshooting){
    message(paste('xlab doing, Bait: \n',print(bait)))
  }
  
  ylab='% reads per promoter (PRPP)'
  xlab=paste(as.character(seqnames(bait)),':',xlim[1],'-',xlim[2],sep='')
  
  if (troubleshooting){
    message(paste('xlab done, Bait: \n',print(bait)))
  }
  
  
  bed=LL[[1]]
  plot((end(bed)+start(bed))/2,bed$x,type='l',lwd=lwd,xlim=xlim,col=colors[1],ylab=ylab,xlab=xlab,main=paste(main,', TSS+/-',zoom/1000000,'Mb, k=',k) , ylim=ylim)
  for (j in 2:length(LL)){
    bed=LL[[j]]
    lines((end(bed)+start(bed))/2,bed$x,type='l',xlim=xlim,col=colors[j],lwd=lwd)
  }
  
  
  
  b=getbaitplus(id)
  rect(xleft = start(b), xright=end(b),ybottom = 0,ytop=ylim[2], col='green',border = NA)
  
  ##plot signficant interactions
  if(!is.null(d)){
    ib=d[d$baitID==id,]
    ibb=GRanges(ib$seqnames_otherEnd, IRanges(ib$start_otherEnd,ib$end_otherEnd))
    values(ibb)=ib
    ib=ibb
    
    cols=list(rgb(1,0,0,alpha=0.1), rgb(0,0,1,alpha=0.1), rgb(0,0,0,alpha=0.1), rgb(0,1,0,alpha=0.1), rgb(1,1,0,alpha=0.1),rgb(1,0,1,alpha=0.1),rgb(0,1,1,alpha=0.1),rgb(0,0.5,0.5,alpha=0.1))
    clust=clust[order(clust)]
    
    for (j in 1:length(clust)){
      
      cl=clust[j]
      col=cols[[j]]
      
      lost=ib[grep(cl,ib$clusters_refined)]
      
      if (length(lost)>0){
        if (length(unique(clust))==1){
          rect(xleft = start(lost), xright=end(lost),ybottom = -0,ytop=(max(all)+1), col= col,border = NA)
        } else {
          rect(xleft = start(lost), xright=end(lost),ybottom = -0,ytop=(max(all)+1), col= col,border = rgb(0,0,0,alpha=0.25))
        }
      }
      
      
    }
    
    legend('topleft', legend=clust,  bty='n',cex=0.8, fill=unlist(cols)[1:length(clust)])
    
  }
  
  ##Plot intervals
  
  
  if (!is.null(intervals)){
    
    abline(h=0)
    
    if (is.null(colintervals)){
      colintervals=c('grey','pink','purple','green','red','blue','orange','black','darkred','darkgreen')
    } 
    
    grl=intervals
    col=colintervals[1:length(grl)]
    
    for (i in 1:length(grl)){
      gr=grl[[i]]
      gr=gr[ as.character(seqnames(gr))==as.character(seqnames(bait))]
      if (length(gr)>0){
        st=0.05*ylim[2]
        step=st*i
        if ( length(grep('TAD',names(grl)[i])) >0 ){
          rect(xleft = start(gr), xright=end(gr),ybottom = (0-step) ,ytop=(0-step)+step/i, col= col[i])
        } else {
          rect(xleft = start(gr), xright=end(gr),ybottom = (0-step) ,ytop=(0-step)+step/i, col= col[i],border=NA)
        }
      }
    }
    legend('bottomright',fill=col,legend=names(grl),bty='n',cex=0.7)
  }
  
  if (!is.null(show.legend) & show.legend==TRUE){
    legend('topright',legend=legend,col=legendcols,lwd=2,bty='n',ncol=2)
  }
}





getsk <- function(L){
  ##returns a vector with scaling factors for all cd@x objects in list of cd@x objects L
  ##scaling factors are then used to multiply N reads in cd@x objects with them to obtain %reads per sample per promoter (PRSP) * 1000
  
  
  cov=vector()
  nprom=vector()
  for (i in 1:length(L)){
    a=L[[i]]
    b=sum(a$N)
    cov=c(cov,b)
    nprom=c(nprom,length(unique(a$baitID)))
  }
  
  names(cov)=names(L)
  sk=1/cov*nprom*100*1000
  names(sk)=names(L)
  
  return(sk)
}



##v2:
getnormbed <- function(id,data,samplename,L,same.chromosome=FALSE,bait,p=0,hind){
  ##returns a normalized gr object for a specific bait, normalized by Chicago scaling factors
  ##
  ##arguments:
  ##id = baitID
  ##data=cd@x for a specific sample
  ##samplename = name of the sample, has to be the same as the name of the scaling factors sk
  ##L=list of cd@x objects for which to calculate sk
  ##same.chromosome: should only reads from teh same chromosome be taken? default:FALSE
  ##p:pseudocount to add before normalization, default:0
  
  
  sk=getsk(L)
  names(sk)=names(L)
  s=sk[samplename]
  
  a=data[data$baitID==id,]
  a=a[order(a$otherEndID),]
  bed=hind[hind$id %in% a$otherEndID]
  values(bed)=cbind(values(bed),as.data.frame(a)[, grep('N',names(a))])
  summary(bed$id==a$otherEndID)
  bait=resize(hind[hind$id %in% a$baitID],1,fix='center')
  if (same.chromosome==TRUE){
    bed=bed[seqnames(bed)==seqnames(bait)]
  }
  bed$intID=paste(bait$id,bed$id,sep=';')
  
  ##normalize N using the scaling factors:
  bed$N=(bed$N+p)*s
  
  return(bed)
  
}



	
	
